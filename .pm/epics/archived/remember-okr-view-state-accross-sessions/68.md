---
name: Load and save expanded OKR IDs in OKRView.svelte
status: open
created: 2026-02-08T10:04:00Z
updated: 2026-02-08T10:06:47Z
github: https://github.com/rknuus/Bearing/issues/68
depends_on: [66, 67]
parallel: false
conflicts_with: []
---

# Task: Load and save expanded OKR IDs in OKRView.svelte

## Description
Modify `OKRView.svelte` to initialize `expandedIds` from the persisted navigation context on mount, and add an `$effect` to save the current expanded IDs back to the navigation context when they change. This mirrors the existing pattern for `showCompleted`/`showArchived`.

## Acceptance Criteria
- [ ] On mount, `expandedIds` is populated from `navCtx.expandedOkrIds` (if present)
- [ ] When a node is expanded or collapsed, the updated set is saved to NavigationContext
- [ ] Navigating away from OKR view and back restores expanded state
- [ ] Closing and reopening the app restores expanded state
- [ ] Stale IDs (referencing deleted items) are silently ignored — no errors
- [ ] Newly created items that auto-expand (via `expandId()`) are persisted
- [ ] The `$effect` uses `untrack()` correctly to avoid infinite reactive loops
- [ ] The highlight-expand `$effect` (for `highlightItemId`) continues to work correctly
- [ ] Works in both native Wails app and browser mock (`localhost:5173`)

## Technical Details
- File: `frontend/src/views/OKRView.svelte`

**Load on mount** (modify existing `onMount` ~line 418):
```typescript
// After loading navCtx:
if (navCtx?.expandedOkrIds?.length) {
  for (const id of navCtx.expandedOkrIds) {
    expandedIds.add(id);
  }
}
```

**Save on change** (new `$effect`, mirror the pattern at ~line 432):
```typescript
$effect(() => {
  // Read expandedIds.size to track changes (SvelteSet mutations update .size reactivity)
  const _size = expandedIds.size;
  const ids = [...expandedIds];
  untrack(() => {
    getBindings().LoadNavigationContext().then((ctx) => {
      if (ctx) {
        getBindings().SaveNavigationContext({ ...ctx, expandedOkrIds: ids });
      }
    }).catch(() => { /* ignore */ });
  });
});
```

**Key consideration**: `SvelteSet.size` is reactive and updates on add/delete, so reading it in the `$effect` establishes the dependency. The actual save must be in `untrack()` to avoid the infinite loop rule.

## Dependencies
- [ ] Task #66 (Go backend has the field)
- [ ] Task #67 (TypeScript interface has the field)

## Effort Estimate
- Size: S
- Hours: 0.5
- Parallel: false

## Definition of Done
- [ ] Code implemented
- [ ] Frontend lint passes (`make frontend-lint`)
- [ ] Frontend type check passes (`make frontend-check`)
- [ ] Manual verification: expand nodes → navigate away → navigate back → nodes still expanded
